"use strict";(self.webpackChunkswiftui_realm_app=self.webpackChunkswiftui_realm_app||[]).push([[9768],{4137:(e,t,r)=>{r.d(t,{Zo:()=>h,kt:()=>m});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),u=c(r),p=n,m=u["".concat(l,".").concat(p)]||u[p]||d[p]||s;return r?a.createElement(m,o(o({ref:t},h),{},{components:r})):a.createElement(m,o({ref:t},h))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=r.length,o=new Array(s);o[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:n,o[1]=i;for(var c=2;c<s;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}p.displayName="MDXCreateElement"},2608:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var a=r(7462),n=(r(7294),r(4137));const s={},o="How Atlas Search Works",i={unversionedId:"full-text-search/how-search-works",id:"full-text-search/how-search-works",title:"How Atlas Search Works",description:"Atlas Search uses inverted indexes to support text search queries. An inverted index is a data structure that maps each unique term in a collection to the documents that contain that term. The index is sorted by term, with each term referencing the documents that contain it.",source:"@site/docs/1-full-text-search/4-how-search-works.mdx",sourceDirName:"1-full-text-search",slug:"/full-text-search/how-search-works",permalink:"/search-party-lab/docs/full-text-search/how-search-works",draft:!1,editUrl:"https://github.com/mongodb-developer/search-party-lab/blob/main/docs/1-full-text-search/4-how-search-works.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Why Atlas Search",permalink:"/search-party-lab/docs/full-text-search/why-atlas-search"},next:{title:"Start Searching",permalink:"/search-party-lab/docs/category/start-searching"}},l={},c=[{value:"Simple String Search",id:"simple-string-search",level:2},{value:"Full Text Search",id:"full-text-search",level:2},{value:"Index Creation",id:"index-creation",level:2}],h={toc:c},u="wrapper";function d(e){let{components:t,...s}=e;return(0,n.kt)(u,(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"how-atlas-search-works"},"How Atlas Search Works"),(0,n.kt)("p",null,"Atlas Search uses inverted indexes to support text search queries. An inverted index is a data structure that maps each unique term in a collection to the documents that contain that term. The index is sorted by term, with each term referencing the documents that contain it."),(0,n.kt)("h2",{id:"simple-string-search"},"Simple String Search"),(0,n.kt)("p",null,"When you do a simple query in your database using a LIKE operator, or a regular expression, the database has to scan every document in the collection to find the matching documents. This is a slow process, and it gets slower as the number of documents in the collection increases."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Simple String Search",src:r(6761).Z,width:"754",height:"156"})),(0,n.kt)("h2",{id:"full-text-search"},"Full Text Search"),(0,n.kt)("p",null,"Full-text search is meant to search large amounts of text. For example, a search engine will use a full-text search to look for keywords in all the web pages that it indexed. The key to this technique is indexing."),(0,n.kt)("p",null,"Indexing can be done in different ways, such as batch indexing or incremental indexing. The index then acts as an extensive glossary for any matching documents. Various techniques can then be used to extract the data. Apache Lucene, the open sourced search library, uses an inversed index to find the matching items. In the case of our menu search, each word links to the matching menu item."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Full Text Search",src:r(7923).Z,width:"754",height:"298"})),(0,n.kt)("p",null,"This technique is much faster than string searches for large amounts of data."),(0,n.kt)("h2",{id:"index-creation"},"Index Creation"),(0,n.kt)("p",null,"In order to prepare your data to be indexed, your data will go through a process called tokenization. Tokenization is the process of breaking a stream of text up into words, phrases, symbols, or other meaningful elements called tokens. This is done through a series of analyzers. Analyzers are the building blocks of the search engine. They are responsible for producing tokens out of the text. The tokens are then stored in the index."),(0,n.kt)("p",null,"In our example, it will start by removing any diacritics (marks placed above or below letters, such as \xe9, \xe0, and \xe7 in French). Then, based on the used language, the algorithms will remove filler words and only keep the stem of the terms. This way, \u201cto eat,\u201d \u201ceating,\u201d and \u201cate\u201d are all classified as the same \u201ceat\u201d keyword. It then changes the casing to use only either uppercase or lowercase. The exact indexing process is determined by the analyzer that is used."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Analyzer",src:r(8370).Z,width:"1303",height:"589"})),(0,n.kt)("p",null,"In the end, the index will look like a glossary of all the meaningful words in your data. Each word will be linked to the documents that contain it."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Glossary",src:r(3260).Z,width:"826",height:"457"})))}d.isMDXComponent=!0},6761:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/3-string-search-953a4b9a3361b0e76d96710a33f1962c.gif"},7923:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/4-full-text-search-db0022853c7bbb4ce17cbe4109c6747c.gif"},8370:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/5-analyzer-3029ddf907bf3f5667bccc8e6557d254.png"},3260:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/6-glossary-d317195d862c5ec004a0d9d43090d54b.png"}}]);